---
format: "html"
execute:
  echo: false
  warning: false
from: "markdown+emoji"
---

```{r setup}
#| include: false
source(here::here("R/load_libs.R"))
source(here::here("R/load_data.R"))
ggplot2::theme_set(theme_ts)

# DEBUG
#params <- list(region = "Ostwerk")
# params <- list(region = "Süden")

```

```{r filter-region_curr}
# FILTER
filter_by_ids <- function(lst, filter_ids, table_id) {
  lapply(
    lst,
    function(tbl) {
      if(table_id %in% names(tbl)){
        dplyr::filter(tbl, get(table_id) %in% filter_ids)
      }else{
        dplyr::filter(tbl, region_grouped==params$region)
      }
    }
  )
}

filter_by_region<- function(ds) {
  ds$og$data<-ds$og$data %>%
  filter(region_grouped==params$region)
  og_filtered_ids=ds$og$data$og_id
  ds$og$long <- filter_by_ids(ds$og$long, og_filtered_ids, "og_id")
  ds$og$agg <- filter_by_ids(ds$og$agg, og_filtered_ids, "og_id")

  ds$tn$data<-ds$tn$data %>%
    filter(region_grouped==params$region)
  tn_filtered_ids=ds$tn$data$tn_id
  ds$tn$long <- filter_by_ids(ds$tn$long, tn_filtered_ids, "tn_id")
  ds$tn$wide <- filter_by_ids(ds$tn$wide, tn_filtered_ids, "tn_id")
  ds
}

is_westbund <- identical(params$region, "Westbund")

curr<-filter_by_region(curr)
if (has_previous_year) {
  prev<-filter_by_region(prev)
}

# og_tn_only_curr <- curr$tn$data %>% 
#   filter(!og_name %in% curr$og$data$og_name)

og_ids_curr <- curr$og$data$og_id |> unique()
tn_data_f_curr <- curr$tn$data |> 
    filter(og_region == params$region)

og_ids_prev <- if (has_previous_year) prev$og$data$og_id |> unique() else integer(0)

tn_data_f_prev <- if (has_previous_year) {
  prev$tn$data |> 
    filter(og_region == params$region)
} else {
  tibble::tibble()
}


og_nach_tn=length(drop_na_ka(unique(curr$tn$data$og_name)))
og_nach_og=nrow(curr$og$data)
tn_nach_tn=nrow(curr$tn$data)
tn_nach_og <- sum(curr$og$data$anzahl_tn, na.rm = T)
leitung_og_curr <- sum(curr$og$data$anzahl_ma_leitung, na.rm = T)
insgesamt_og_curr <- sum(curr$og$data$anzahl_insg, na.rm = T)

```

```{r display-logo}

logo_path <- file.path("..", "logos", paste0(tolower(params$region), ".png"))

if (file.exists(logo_path)) {
knitr::include_graphics(logo_path)
}

```

Auf dieser Seite werden euch Ergebnisse der Befragung angezeigt, die die TEN SING Region `{r} params$region` betreffen.

```{r}
#| results: asis
if (og_nach_tn >= og_nach_og) {
   s <- sprintf("
  Im Folgenden seht ihr eine Übersicht über die einzelnen Ortsgruppen der Region %s. Laut Teilnehmer*innen-Fragebogen gibt es %i Ortsgruppe(n).<sup>1</sup> Für %i Ortsgruppen wurde der Ortsgruppen-Fragebogen ausgefüllt.<sup>2</sup>", params$region, og_nach_tn, og_nach_og)
} else {
  s <- sprintf("
  Im Folgenden seht ihr eine Übersicht über die einzelnen Ortsgruppen der Region %s. Für %i Ortsgruppen wurde der Ortsgruppen-Fragebogen ausgefüllt.<sup>2</sup> Aus %i Ortsgruppen haben TEN SINGende den Teilnehmer*innen-Fragebogen beantwortet.<sup>1</sup>", params$region, og_nach_og, og_nach_tn)
}

if (og_nach_og == 0) {
  s <- paste(s, "Deshalb können einige Grafiken leider nicht angezeigt werden, da die Daten fehlen.")
}
cat(s, sep = "\n")
```


::: {.callout-note collapse="true"}
## Datenquellen

<sup>1</sup> Anzahl unterschiedlicher Angaben auf die Frage `{r} fmt_q(curr$cfg$tn_cfg$Q_OG_NAME)` im `{r} fmt_fragebogen("tn", url=curr$cfg$tn_cfg$URL)`, die in die Region `r params$region` fallen.

<sup>2</sup> Anzahl Ortsgruppen, die bei der Frage `{r} fmt_q(curr$cfg$og_cfg$Q_OG_REGION)` im `{r} fmt_fragebogen("og", url=curr$cfg$og_cfg$URL)` "`r params$region`" angegeben haben.
:::

Aufgelistet sind die Anzahl der aktiven TEN SINGer*innen pro Ortsgruppe, ihr Durchschnittsalter sowie die Anzahl der Auftritte pro Jahr.



```{r region-table-functions}
create_region_stats_table_default <- function(region_overview){
  weighted_avg <- with(region_overview, {
    idx <- !is.na(avg_alter) & !is.na(n)
    if (!any(idx)) NA_real_ else sum(avg_alter[idx] * n[idx]) / sum(n[idx])
  })

  reactable::reactable(
    region_overview |> 
      dplyr::select(og_name, hat_hauptamt, dplyr::starts_with("anzahl"), auftritte, hat_probleme_tn_gewinnung, avg_alter),
    columns = list(
      og_name = colDef(name = "Orts-<br>gruppe", footer = "Summe / <br> Gesamt", show = TRUE, html = TRUE),
      hat_hauptamt = colDef(name = "Hauptamt", footer = function(values) sprintf("%d", length(drop_na_ka(values[values == "Ja"]))), show = TRUE),
      anzahl_insg = colDef(name = "Aktive", footer = function(values) sprintf("%d", sum(values, na.rm = TRUE)), show = TRUE),
      anzahl_tn = colDef(name = "Teiln.", footer = function(values) sprintf("%d", sum(values, na.rm = TRUE)), show = TRUE),
      anzahl_ma_leitung = colDef(name = "Mitarb.", footer = function(values) sprintf("%d", sum(values, na.rm = TRUE)), show = TRUE),
      auftritte = colDef(name = "Auftritte", footer = function(values) sprintf("%d", sum(drop_na_ka(values))), show = TRUE),
      avg_alter = colDef(
        name = "Durch-<br>schnitts-<br>alter*",
        footer = function(values) {
          if (is.na(weighted_avg)) return("–")
          sprintf("%d", round(weighted_avg))
        },
        show = TRUE, html = TRUE
      )
    ),
    defaultColDef = colDef(footerStyle = list(fontWeight = "bold"), show = FALSE)
  )
}

# Westbund-specific table helpers (from previous dedicated template)
create_region_stats_table_westbund <- function(region_overview) {
  og_region_df <- region_overview |>
    dplyr::arrange(og_region, og_name) |>
    dplyr::select(
      og_region,
      og_name,
      hat_hauptamt,
      anzahl_insg,
      anzahl_tn,
      anzahl_ma_leitung,
      auftritte,
      avg_alter,
      n
    )

  og_region_agg <- og_region_df |>
    dplyr::group_by(og_region) |>
    dplyr::summarise(
      n_og               = dplyr::n_distinct(og_name),
      anzahl_insg        = sum(anzahl_insg, na.rm = TRUE),
      anzahl_tn          = sum(anzahl_tn, na.rm = TRUE),
      anzahl_ma_leitung  = sum(anzahl_ma_leitung, na.rm = TRUE),
      auftritte          = sum(auftritte, na.rm = TRUE),
      avg_alter          = {
        idx <- !is.na(avg_alter) & !is.na(n)
        if (!any(idx)) NA_real_
        else sum(avg_alter[idx] * n[idx]) / sum(n[idx])
      },
      .groups = "drop"
    ) |>
    dplyr::arrange(og_region)

  total_og      <- dplyr::n_distinct(og_region_df$og_name)
  total_aktive  <- sum(og_region_df$anzahl_insg, na.rm = TRUE)
  total_tn      <- sum(og_region_df$anzahl_tn, na.rm = TRUE)
  total_ma      <- sum(og_region_df$anzahl_ma_leitung, na.rm = TRUE)
  total_auftr   <- sum(og_region_df$auftritte, na.rm = TRUE)
  overall_avg   <- {
    idx <- !is.na(og_region_df$avg_alter) & !is.na(og_region_df$n)
    if (!any(idx)) NA_real_
    else sum(og_region_df$avg_alter[idx] * og_region_df$n[idx]) /
      sum(og_region_df$n[idx])
  }

  reactable::reactable(
    og_region_agg,
    columns = list(
      og_region = reactable::colDef(name = "Region", minWidth = 140, maxWidth = 150),
      n_og = reactable::colDef(name = "Ortsgruppen", footer = function(values) total_og, minWidth = 110, maxWidth = 120, html = TRUE),
      anzahl_insg = reactable::colDef(name = "Aktive", footer = function(values) total_aktive, minWidth = 65, maxWidth = 120),
      anzahl_tn = reactable::colDef(name = "Teiln.", footer = function(values) total_tn, minWidth = 60, maxWidth = 120),
      anzahl_ma_leitung = reactable::colDef(name = "Mitarb.", footer = function(values) total_ma, minWidth = 70, maxWidth = 120),
      auftritte = reactable::colDef(name = "Auftritte", footer = function(values) total_auftr, minWidth = 80, maxWidth = 120),
      avg_alter = reactable::colDef(
        name   = "Durchschnittsalter*",
        format = reactable::colFormat(digits = 0),
        footer = function(values) sprintf("%d", round(overall_avg)),
        minWidth = 160, maxWidth = 165, html = TRUE
      )
    ),
    defaultColDef = reactable::colDef(
      headerStyle = list(
        whiteSpace    = "nowrap",
        fontSize      = "0.9rem",
        paddingTop    = "2px",
        paddingBottom = "2px",
        lineHeight    = "1.1"
      ),
      style = list(
        fontSize = "0.9rem"
      )
    ),
    defaultSorted = list(og_region = "asc"),
    fullWidth = FALSE,
    details = function(index) {
      region <- og_region_agg$og_region[index]

      child <- og_region_df |>
        dplyr::filter(og_region == region) |>
        dplyr::arrange(og_name) |>
        dplyr::select(
          og_name,
          hat_hauptamt,
          anzahl_insg,
          anzahl_tn,
          anzahl_ma_leitung,
          auftritte,
          avg_alter
        )

      htmltools::div(
        style = "margin-left: 90px; margin-bottom: 40px",
        reactable::reactable(
          child,
          columns = list(
            og_name           = reactable::colDef(name = "Ortsgruppe", minWidth = 150, maxWidth = 120),
            hat_hauptamt      = reactable::colDef(name = "Hauptamt", minWidth = 85, maxWidth = 120),
            anzahl_insg       = reactable::colDef(name = "Aktive", minWidth = 60, maxWidth = 120),
            anzahl_tn         = reactable::colDef(name = "Teiln.", minWidth = 60, maxWidth = 120),
            anzahl_ma_leitung = reactable::colDef(name = "Mitarb.", minWidth = 70, maxWidth = 120),
            auftritte         = reactable::colDef(name = "Auftritte", minWidth = 80, maxWidth = 120),
            avg_alter         = reactable::colDef(
              name   = "Durchschnittsalter*",
              format = reactable::colFormat(digits = 0),
              minWidth = 160, maxWidth = 165
            )
          ),
          defaultColDef = reactable::colDef(
            headerStyle = list(
              whiteSpace    = "nowrap",
              fontSize      = "0.9rem",
              paddingTop    = "2px",
              paddingBottom = "2px",
              lineHeight    = "1.1"
            ),
            style = list(
              fontSize = "0.9rem"
            )
          ),
          pagination = FALSE,
          bordered   = FALSE,
          compact    = TRUE,
          highlight  = TRUE,
          fullWidth  = FALSE
        )
      )
    }
  )
}

create_region_stats_table <- function(region_overview){
  if (is_westbund) {
    return(create_region_stats_table_westbund(region_overview))
  }
  create_region_stats_table_default(region_overview)
}

calculate_region_stats_default <- function(ds){
  ds$og$agg$total_tn_by_og %>%
    dplyr::left_join(
      ds$og$data %>%
        dplyr::select(og_name, hat_probleme_tn_gewinnung, hat_hauptamt, auftritte),
      by = "og_name"
    ) %>%
    dplyr::left_join(
      ds$tn$agg$alter_by_og %>%
        dplyr::select(og_name, avg_alter, n),
      by="og_name"
    )
}

calculate_region_stats_westbund <- function(ds) {
  ds$og$agg$total_tn_by_og |>
    dplyr::filter(region_grouped == params$region) |>
    dplyr::left_join(
      ds$og$data |>
        dplyr::select(
          og_name,
          hat_hauptamt,
          auftritte
        ),
      by = "og_name"
    ) |>
    dplyr::left_join(
      ds$tn$agg$alter_by_og |>
        dplyr::select(og_name, avg_alter, n),
      by = "og_name"
    )
}

calculate_region_stats <-function(ds){
  if (is_westbund) {
    calculate_region_stats_westbund(ds)
  } else {
    calculate_region_stats_default(ds)
  }
}
```

```{r region-overview-tabset, echo=FALSE, results='asis'}
#| fig.width: 9
#| fig.height: 6
region_overview_tabs <- list(
  curr = list(
    year = current_year,
    data = calculate_region_stats(curr)
  )
)

region_overview_tabs$prev <- if (has_previous_year) {
  list(
    year = previous_year,
    data = calculate_region_stats(prev)
  )
} else {
  NULL
}

render_region_overview <- function(tab_data) {
  render_widget_output(create_region_stats_table(tab_data$data))
}

render_year_tabset(
  curr_data = region_overview_tabs$curr,
  prev_data = region_overview_tabs$prev,
  render_fn = render_region_overview
)
```


::: {.callout-note collapse="false"}

## Erklärung

- **Teilnehmende** sind alle, die sich in den Ortsgruppen engagieren und an TEN SING Veranstaltungen teilnehmen, und dabei keine offizielle Leitungsfunktion übernehmen.

- **Mitarbeitende** sind alle hauptamtlichen Mitarbeiter*innen in den Ortsgruppen und Ehrenamtlichen, die eine Verantwortungsfunktion übernehmen.

- Zusätzlich gibt die Spalte **“Hauptamt”** an, ob eine Ortsgruppe hauptamtliche Mitarbeitende hat.

- Die **Aktiven** sind alle Teilnehmenden und Mitarbeitenden zusammen.

:::


::: {.callout-note collapse="true"}

## Datenquellen

⚠️ Durchschnittsalter: 

- Für Ortsgruppen, in denen weniger als 3 Personen die Umfrage beantwortet haben, wird aus Datenschutzgründen kein Durchschnittsalter angezeigt.

- Der Gesamt-Durchschnitt ist ein *gewichteter Mittelwert*. Ortsgruppen mit mehr Teilnehmenden beeinflussen den Wert stärker als solche mit wenigen.

Relevante Fragen:

- **Frage** `{r} fmt_source(curr$cfg$og_cfg$Q_OG_REGION, "og", url=curr$cfg$og_cfg$URL)`
- **Frage** `{r} fmt_source(curr$cfg$og_cfg$Q_OG_NAME, "og", url=curr$cfg$og_cfg$URL)`
- **Frage** `{r} fmt_source(curr$cfg$tn_cfg$Q_OG_NAME, "tn", url=curr$cfg$tn_cfg$URL)` 


| Fragebogen                 | Teilnehmer\*innen | Mitarbeitende | Insgesamt                                 |
|-----------------|-----------------|-----------------|----------------------|
| `{r} fmt_fragebogen("tn", url=curr$cfg$tn_cfg$URL)` | `{r} sum(curr$tn$data$verantwortung_janein == "Nein", na.rm = TRUE)
`  | `{r} sum(curr$tn$data$verantwortung_janein == "Ja", na.rm = TRUE)
`        |       `{r} tn_nach_tn`<sup>1</sup>                |
| `{r} fmt_fragebogen("og", url=curr$cfg$og_cfg$URL)` | `{r} tn_nach_og`       | `{r} leitung_og_curr`          | `{r} sum(curr$og$data$anzahl_insg, na.rm = T)` |


<sup>1</sup>: Anzahl der Antworten auf den `{r} I(fmt_fragebogen(type = "tn", url=curr$cfg$tn_cfg$URL))
`
:::

# Angebote in den Ortsgruppen

Im Folgenden seht ihr, welche Workshops in welcher Ortsgruppe angeboten werden.

```{r angebote-table-functions}
calculate_angebote_table <- function(ds) {
  all_angebote_cols <- sort(unique(c(
    curr$og$long$angebote_vor_ort$angebote_vor_ort,
    prev$og$long$angebote_vor_ort$angebote_vor_ort,
    curr$tn$long$angebote_vor_ort$angebot,
    prev$tn$long$angebote_vor_ort$angebot
  )))

  # we need og_name, angebot
  og_angebot <- ds$og$long$angebote_vor_ort %>%
    merge(ds$og$data %>% select(og_name, og_id)) %>%
    select(og_name, angebote_vor_ort)

  tn_angebot <- ds$tn$long$angebote_vor_ort %>%
    merge(ds$tn$data %>% select(tn_id, og_name)) %>%
    select(angebot, og_name) %>%
    rename(angebote_vor_ort = angebot)

  tn_og_angebot <- bind_rows(og_angebot, tn_angebot)

  tn_og_angebot_wide <- tn_og_angebot %>%
    mutate(value = 1) %>%
    distinct(og_name, angebote_vor_ort, .keep_all = TRUE) %>%
    pivot_wider(
      names_from  = angebote_vor_ort,
      values_from = value,
      values_fill = list(value = 0)
    )

  # fehlende Spalten aus beiden Jahren ergänzen + Reihenfolge festziehen
  missing_cols <- setdiff(all_angebote_cols, names(tn_og_angebot_wide))
  if (length(missing_cols) > 0) {
    tn_og_angebot_wide[missing_cols] <- 0L
  }

  tn_og_angebot_wide <- tn_og_angebot_wide %>%
    select(og_name, dplyr::all_of(all_angebote_cols)) %>%
    filter(!is.na(og_name))

  # if there are no angebot columns, return an empty table
  if (ncol(tn_og_angebot_wide) <= 1) {
    return(
      tibble::tibble(
        og_name = character(),
        angebot = character(),
        has     = integer(),
        label   = character(),
        col     = character(),
        bg      = character(),
        og_region = character()
      )
    )
  }

  tn_og_angebot_long <- tn_og_angebot_wide %>%
    pivot_longer(-og_name, names_to = "angebot", values_to = "has") %>%
    mutate(
      label = ifelse(has == 1, "✓", "✗"),
      col   = ifelse(has == 1, "#2ca02c", "#a4a4a4ff"),
      bg    = ifelse(has == 1, "#e6f6e6", NA_character_)
    ) %>%
    left_join(
      ds$og$agg$total_tn_by_og %>% dplyr::distinct(og_name, og_region),
      by = "og_name"
    )

  tn_og_angebot_long
}

display_angebote_table <-function(angebote){
  if (nrow(angebote) == 0) {
    return(ts_no_data_girafe())
  }

  p <- ggplot(angebote, aes(x = angebot, y = og_name)) +
    ggiraph::geom_tile_interactive(
      aes(
        fill = factor(has),
        tooltip = paste0(og_name, "\n", angebot, ": ", label),
        data_id = paste(og_name, angebot, sep = "-")
      ),
      color = "grey80"
    ) +
    geom_text(aes(label = label, colour = col), size = 10, fontface = "bold", show.legend = FALSE) +
    scale_fill_manual(
      values = c(
        "1" = "#e6f6e6",  # light green for ✓
        "0" = "#ffffff"   # white for ✗
      ),
      guide = "none"
    )+
    scale_colour_identity() +
    coord_fixed() +
    theme_minimal(base_size = 12, base_family = TS_FONT_FAMILY) +
    theme(
      axis.text.x  = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      panel.grid      = element_blank(),
      plot.title = element_text(
        hjust = 0.5,
        family = TS_FONT_FAMILY,
        face = "bold",
        size = 16
      )
    ) +
    labs(x = NULL, y = NULL, title="Welche Workshops werden vor Ort angeboten?")

  ggiraph::girafe(
    ggobj = p,
    options = list(
      ggiraph::opts_toolbar(saveaspng = TRUE)
    )
  )
}

```


```{r angebote-tabset, echo=FALSE, results='asis'}
#| fig.width: 9
#| fig.height: 6
angebote_tabs <- list(
  curr = list(
    year = current_year,
    data = calculate_angebote_table(curr)
  )
)

angebote_tabs$prev <- if (has_previous_year) {
  list(
    year = previous_year,
    data = calculate_angebote_table(prev)
  )
} else {
  NULL
}

render_angebote_table <- function(tab_data) {
  angebote <- tab_data$data
  regions <- sort(unique(angebote$og_region[!is.na(angebote$og_region)]))

  force_tabset <- is_westbund

  if (length(regions) <= 1 && !force_tabset) {
    render_widget_output(display_angebote_table(angebote))
    return(invisible(NULL))
  }

  cat("::: {.panel-tabset}\n\n")
  for (reg in regions) {
    cat("## ", reg, "\n\n", sep = "")
    widget <- display_angebote_table(
      dplyr::filter(angebote, og_region == reg)
    )
    render_widget_output(widget)
    cat("\n\n")
  }
  cat(":::\n")
}

render_year_tabset(
  curr_data = angebote_tabs$curr,
  prev_data = angebote_tabs$prev,
  render_fn = render_angebote_table
)

knitr::asis_output(callout_datenquellen(curr$cfg,
og_q=list("Q_WORKSHOPS"),
tn_q=list("Q_ANGEBOTE_VOR_ORT")
))

```

Zusätzlich wollten wir von euch wissen, an welchen Workshops ihr teilnehmt! So habt ihr geantwortet:

```{r calculate-plot-angebot}
all_angebote_levels <- curr$tn$long$angebote_vor_ort$angebot
if (has_previous_year) {
  all_angebote_levels <- c(all_angebote_levels, prev$tn$long$angebote_vor_ort$angebot)
}
all_angebote_levels <- sort(unique(all_angebote_levels))

calculate_agg_angebot <- function(ds) {
  angebot_tn <- ds$tn$long$angebote_vor_ort %>%
    dplyr::left_join(
      ds$tn$data %>% dplyr::select(tn_id, og_region),
      by = "tn_id"
    )

  has_region_info <- any(!is.na(angebot_tn$og_region))
  force_region_view <- is_westbund

  if (!has_region_info && !force_region_view) {
    counts <- ds$tn$long$angebote_vor_ort |>
      dplyr::count(angebot, name = "n")

    return(
      tibble::tibble(angebot = all_angebote_levels) |>
        dplyr::left_join(counts, by = "angebot") |>
        tidyr::replace_na(list(n = 0L)) |>
        dplyr::mutate(
          percent = dplyr::if_else(nrow(ds$tn$data) > 0, n / nrow(ds$tn$data), NA_real_),
          og_region = params$region
        )
    )
  }

  angebot_tn <- angebot_tn %>%
    dplyr::filter(!is.na(og_region)) %>%
    dplyr::distinct(tn_id, og_region, angebot)

  denom <- ds$tn$data %>%
    dplyr::filter(!is.na(og_region)) %>%
    dplyr::count(og_region, name = "n_tn_region")

  angebot_tn %>%
    dplyr::count(og_region, angebot, name = "n") %>%
    tidyr::complete(
      og_region,
      angebot = all_angebote_levels,
      fill = list(n = 0)
    ) %>%
    dplyr::left_join(denom, by = "og_region") %>%
    dplyr::mutate(
      percent = dplyr::if_else(n_tn_region > 0, n / n_tn_region, NA_real_)
    )
}

plot_agg_angebot <- function(angebote_agg) {
  if (!any(angebote_agg$n > 0, na.rm = TRUE)) {
    return(ts_no_data_girafe())
  }

  region_title <- NULL
  reg <- unique(angebote_agg$og_region)
  reg <- reg[!is.na(reg)]
  if (length(reg) == 1) {
    region_title <- paste0("An welchen Angeboten nehmen TEN SINGende teil? – ", reg)
  } else {
    region_title <- "An welchen Angeboten nehmen TEN SINGende teil?"
  }

  p_ang_tn <- ggplot(
    angebote_agg,
    aes(y = angebot, x = percent)
  ) +
    ggiraph::geom_col_interactive(
      aes(tooltip = paste0(angebot, "\n", round(percent * 100, 2), "%")),
      fill = TS_GREEN
    ) +
    scale_y_discrete(limits = rev) +  
    scale_x_continuous(labels = scales::label_percent(), limits = c(0, 1)) +
    labs(
      y = NULL,
      x = "% der Teilnehmenden",
      title = region_title,
      caption = "% summieren nicht zu 100, da Mehrfachauswahl möglich."
    )

  ggiraph::girafe(
    ggobj = p_ang_tn,
    options = list(
      ggiraph::opts_toolbar(saveaspng = TRUE)
    )
  )
}

```

```{r angebote-agg-tabset, echo=FALSE, results='asis'}
#| fig.width: 9
#| fig.height: 6
angebote_agg_tabs <- list(
  curr = list(
    year = current_year,
    data = calculate_agg_angebot(curr)
  )
)

angebote_agg_tabs$prev <- if (has_previous_year) {
  list(
    year = previous_year,
    data = calculate_agg_angebot(prev)
  )
} else {
  NULL
}

render_angebote_agg_plot <- function(tab_data) {
  angebote_agg <- tab_data$data
  regions <- sort(unique(angebote_agg$og_region[!is.na(angebote_agg$og_region)]))

  force_tabset <- is_westbund

  if (length(regions) <= 1 && !force_tabset) {
    render_widget_output(plot_agg_angebot(angebote_agg))
    return(invisible(NULL))
  }

  cat("::: {.panel-tabset}\n\n")
  for (reg in regions) {
    cat("## ", reg, "\n\n", sep = "")
    region_data <- dplyr::filter(angebote_agg, og_region == reg)
    render_widget_output(
      plot_agg_angebot(region_data)
    )
    cat("\n\n")
  }
  cat(":::\n")
}

render_year_tabset(
  curr_data = angebote_agg_tabs$curr,
  prev_data = angebote_agg_tabs$prev,
  render_fn = render_angebote_agg_plot
)

```

```{r}
#| results: asis

if (!is_westbund) {
  angebot_anz_ges <- length(unique(curr$tn$long$angebote_vor_ort$tn_id))
  angebot_anz_theater <- curr$tn$long$angebote_vor_ort %>%
    filter(angebot == "Theater") %>%
    pull(tn_id) %>%
    n_distinct()
  angebot_perc_theater = round(angebot_anz_theater / angebot_anz_ges, 2)

  callout <- sprintf(
    "::: {.callout-tip collapse=\"false\"} \n## Interpretationshilfe\n\n Insgesamt %d Personen haben im Jahr %s eine Antwort auf diese Frage gegeben. %d Personen gaben wiederum an, dass sie gerne am Theaterworkshop/Theaterangebot teilnehmen. %d von %d Personen entspricht %s Prozent. Diesen Wert seht ihr im oberen Schaubild visualisiert. Da eine Mehrfachauswahl möglich war, summieren sich die Werte auf mehr als 100%%.\n:::",
    angebot_anz_ges,
    current_year,
    angebot_anz_theater,
    angebot_anz_theater,
    angebot_anz_ges,
    fmt_perc(angebot_perc_theater)
  )

  cat(callout)
}
```


```{r datenquellen-angebote}
knitr::asis_output(callout_datenquellen(curr$cfg,
tn_q=list("Q_ANGEBOTE_VOR_ORT")
))
```

## Neue Teilnehmer*innen

Die Arbeit von TEN SING lebt vom Engagement vieler Menschen. Deshalb ist die Gewinnung neuer Teilnehmer*innen genauso wichtig wie ein beständiges Team. Aus diesem Grund wollten wir wissen, wie neue Teilnehmende zu TEN SING kommen - oder genauer gesagt: zu TEN SING `{r} params$region`!

```{r calculate-plot-zugang}
all_zugang_levels <- curr$tn$long$zugangsweg$zugangsweg
if (has_previous_year) {
  all_zugang_levels <- c(all_zugang_levels, prev$tn$long$zugangsweg$zugangsweg)
}
all_zugang_levels <- sort(unique(all_zugang_levels))

zugang_choices_all <- curr$meta$tn_choices |>
  dplyr::filter(list_name == curr$cfg$tn_cfg$Q_ZUGANGSWEGE$select_from_list_name) |>
  dplyr::mutate(
    label_manual = curr$cfg$tn_cfg$LABEL_ZUGANGSWEGE,
    label_short = stringr::str_to_title(
      stringr::str_replace_all(name, "_", " ")
    )
  ) |>
  dplyr::filter(label %in% all_zugang_levels) |>
  dplyr::transmute(
    zugangsweg = label,
    label_short,
    label_manual
  )

calculate_zugang_prop <- function(ds) {
  zugang_long <- ds$tn$long$zugangsweg %>%
    dplyr::left_join(
      ds$tn$data %>% dplyr::select(tn_id, og_region),
      by = "tn_id"
    )

  subregions <- unique(zugang_long$og_region[!is.na(zugang_long$og_region)])
  has_multiple_regions <- length(subregions) > 1
  force_region_view <- is_westbund

  if (!has_multiple_regions && !force_region_view) {
    counts <- zugang_long |>
      dplyr::count(zugangsweg, name = "n")

    return(
      zugang_choices_all |>
        dplyr::left_join(counts, by = "zugangsweg") |>
        tidyr::replace_na(list(n = 0)) |>
        dplyr::mutate(
          total_n = nrow(ds$tn$data),
          prop = dplyr::if_else(total_n > 0, n / total_n, NA_real_),
          og_region = params$region
        )
    )
  }

  denom <- ds$tn$data %>%
    dplyr::filter(!is.na(og_region)) %>%
    dplyr::count(og_region, name = "n_tn_region")

  zugang_counts <- zugang_long %>%
    dplyr::filter(!is.na(og_region)) %>%
    dplyr::count(og_region, zugangsweg, name = "n")

  zugang_counts %>%
    tidyr::complete(
      og_region,
      zugangsweg = zugang_choices_all$zugangsweg,
      fill = list(n = 0)
    ) %>%
    dplyr::left_join(
      zugang_choices_all,
      by = "zugangsweg"
    ) %>%
    dplyr::left_join(denom, by = "og_region") %>%
    dplyr::mutate(
      prop = dplyr::if_else(n_tn_region > 0, n / n_tn_region, NA_real_),
      total_n = n_tn_region
    )
}

plot_zugang_prob <- function(zugang_prop) {
  if (!any(zugang_prop$total_n > 0, na.rm = TRUE)) {
    return(ts_no_data_girafe())
  }

  reg <- unique(zugang_prop$og_region)
  reg <- reg[!is.na(reg)]
  title <- if (length(reg) == 1) {
    paste0("Wie kommen neue Teilnehmende zu TEN SING? – ", reg)
  } else {
    "Wie kommen neue Teilnehmende zu TEN SING?"
  }

  p <- ggplot(
    zugang_prop,
    aes(y = label_short, x = prop)
  ) +
    ggiraph::geom_col_interactive(
      aes(tooltip = paste0(label_manual, "\n", fmt_perc(prop))),
      fill = TS_GREEN
    ) +
    scale_y_discrete(limits = rev) +  

    scale_x_continuous(labels = fmt_perc, limits = c(0, 1)) +
    labs(
      y = NULL,
      x = "% der Teilnehmenden",
      caption = "% summieren nicht zu 100, da Mehrfachauswahl möglich.",
      title = title
    )

  ggiraph::girafe(
    ggobj = p,
    options = list(
      ggiraph::opts_toolbar(saveaspng = TRUE)
    )
  )
}

```

```{r zugang-tabset, echo=FALSE, results='asis'}
#| fig.width: 9
#| fig.height: 6
zugang_prop_tabs <- list(
  curr = list(
    year = current_year,
    data = calculate_zugang_prop(curr)
  )
)

zugang_prop_tabs$prev <- if (has_previous_year) {
  list(
    year = previous_year,
    data = calculate_zugang_prop(prev)
  )
} else {
  NULL
}

zugang_prop_curr <- zugang_prop_tabs$curr$data
zugang_prop_prev <- if (has_previous_year) zugang_prop_tabs$prev$data else NULL

render_zugang_plot <- function(tab_data) {
  zugang_prop <- tab_data$data
  regions <- sort(unique(zugang_prop$og_region[!is.na(zugang_prop$og_region)]))

  force_tabset <- is_westbund

  if (length(regions) <= 1 && !force_tabset) {
    render_widget_output(plot_zugang_prob(zugang_prop))
    return(invisible(NULL))
  }

  cat("::: {.panel-tabset}\n\n")
  for (reg in regions) {
    cat("## ", reg, "\n\n", sep = "")
    region_data <- dplyr::filter(zugang_prop, og_region == reg)
    render_widget_output(
      plot_zugang_prob(region_data)
    )
    cat("\n\n")
  }
  cat(":::\n")
}

render_year_tabset(
  curr_data = zugang_prop_tabs$curr,
  prev_data = zugang_prop_tabs$prev,
  render_fn = render_zugang_plot
)

```

```{r zugang-interpretation-flags}
zugang_has_subregions <- is_westbund

if (!zugang_has_subregions) {
  example_proz_curr <- zugang_prop_curr %>% 
    dplyr::filter(label_short == "Andere Person") %>% 
    dplyr::pull(prop)
}
```

::: {.callout-tip collapse="true"}

## Interpretationshilfe

- y-Achse/senkrechte Achse: Antwortoptionen, die ausgewählt werden konnten. 
- x-Achse/waagerechte Achse: Prozentzahl der Teilnehmer\*innen, die diese Option als _eine ihrer Antworten_ ausgewählt haben. 
- `r if (zugang_has_subregions) "Mehrfachauswahl: Prozentzahlen summieren sich innerhalb der Unterregionen nicht auf 100%." else sprintf("Mehrfachauswahl: Die Prozentzahlen summieren sich im Jahr %s auf %s%%, da mehrere Antworten möglich waren.", current_year, round(sum(zugang_prop_curr$prop) * 100,1))`

`r if (!zugang_has_subregions) sprintf("**Beispielinterpretation**: %sder Teilnehmenden gaben im Jahr %s **als einen** ihrer Zugangswege zu TEN SING an, von einer anderen Person mitgenommen worden zu sein.", fmt_perc(example_proz_curr), current_year) else ""`

:::


```{r Q_ZUGANGSWEGE DQ}
knitr::asis_output(callout_datenquellen(curr$cfg,
tn_q=list("Q_ZUGANGSWEGE")
))
```

```{r calc-plot-massnahmen-erfolg}
calculate_massnahmen_long<-function(ds){
  mass_choices<- ds$meta$og_choices %>% 
  filter(list_name == curr$cfg$og_cfg$Q_TN_GEWINNUNG_MASSNAHMEN$select_from_list_name) %>% 
  mutate(label_short = str_to_title(str_replace_all(name, "_", " "))) %>% 
  select(name, label, label_short)
  erfolg_choices=get_erfolg_choices(ds)
  mass_long <- ds$og$long$tn_gewinnung_massnahmen %>% 
  left_join(ds$og$data %>% select(og_id, hat_probleme_tn_gewinnung), by = "og_id") %>% 
  left_join(mass_choices, by = c("massnahme" = "label")) %>% 
  left_join(erfolg_choices)
  mass_long
}

get_erfolg_choices <-function(ds){  
  erfolg_choices<- ds$meta$og_choices %>% 
  filter(list_name == ds$cfg$og_cfg$QS_TN_GEWINNUNG_MASSNAHMEN_ERFOLG$select_from_list_name[1]) %>% 
  mutate(erfolg = as.integer(name)) %>% 
  select(erfolg, erfolg_label = label)
  erfolg_choices
}

calculate_massnahmen_erfolg_agg <- function(ds, mass_long, mass_count_agg) {
  erfolg_choices <- get_erfolg_choices(ds)
  base_grid <- tidyr::crossing(
    mass_count_agg %>%
      dplyr::filter(massnahme != "Insgesamt") %>%
      dplyr::select(massnahme, label_short),
    erfolg_choices
  )
  erfolg_counts <- mass_long %>%
    dplyr::filter(massnahme != "Insgesamt") %>%
    dplyr::count(massnahme, label_short, erfolg, erfolg_label, name = "n_erf")
  mass_erfolg_agg <- base_grid %>%
    dplyr::left_join(
      mass_count_agg %>%
        dplyr::filter(massnahme != "Insgesamt") %>%
        dplyr::select(massnahme, label_short, n),
      by = c("massnahme", "label_short")
    ) %>%
    dplyr::left_join(
      erfolg_counts,
      by = c("massnahme", "label_short", "erfolg", "erfolg_label")
    ) %>%
    tidyr::replace_na(list(n = 0L, n_erf = 0L)) %>%
    dplyr::mutate(
      perc = dplyr::if_else(n > 0, n_erf / n, NA_real_),
      label_short = factor(
        label_short,
        levels = sort(unique(mass_count_agg$label_short))
      )
    )
  mass_erfolg_agg
}

plot_massnahmen <- function(mass_count_agg) {
  if (!any(mass_count_agg$n > 0, na.rm = TRUE)) {
    return(ts_no_data_girafe())
  }

  mass_count_agg <- mass_count_agg |>
    dplyr::mutate(
      label_short = factor(label_short,
      levels = sort(unique(label_short)))
    )

  max_n <- max(mass_count_agg$n, na.rm = TRUE)

  p <- ggplot(mass_count_agg, aes(y = label_short, x = n)) +
    ggiraph::geom_col_interactive(fill = TS_GREEN,    aes(
      tooltip = paste0(massnahme, "\nAnzahl: ", n),
      data_id = paste0(massnahme, "_", label_short)
    )) +
    scale_y_discrete(limits = rev) +  

    scale_x_continuous(breaks = seq(0, max_n, by = 1)) +
    labs(
      x = "Anzahl der Ortsgruppen",
      y = NULL,
      title = "Maßnahmen zur Teilnehmendengewinnung",
      subtitle = "in den Ortsgruppen",
      caption = "Mehrfachauswahl möglich"
    ) +
    theme(
      plot.title = element_text(
        hjust = 0.5,
        face = "bold",
        family = TS_FONT_FAMILY
      ),
      plot.subtitle = element_text(
        hjust = 0.5,
        family = TS_FONT_FAMILY
      ),
      plot.caption = element_text(
        hjust = 0.5,
        family = TS_FONT_FAMILY
      )
    )

  ggiraph::girafe(
    ggobj = p,
    options = list(
      ggiraph::opts_toolbar(saveaspng = TRUE)
    )
  )
}

plot_massnahmen_erfolg <- function(mass_erfolg_agg, ds) {
  if (!any(mass_erfolg_agg$n > 0, na.rm = TRUE)) {
    return(ts_no_data_girafe())
  }

  erfolg_choices <- get_erfolg_choices(ds)

  legend_labels <- stringr::str_wrap(erfolg_choices$erfolg_label, width = 18)

  p <- ggplot(
      mass_erfolg_agg,
      aes(
        fill = forcats::fct_reorder(erfolg_label, as.integer(erfolg)),
        y = label_short,
        x = perc,
        tooltip = paste0(
          massnahme, "\nAntwortoption ", erfolg_label, ": ",
          round(perc * 100, 2), "%"
        )
      )
    ) +
    ggiraph::geom_col_interactive(position = position_stack(reverse = TRUE)) +
    scale_x_continuous(labels = scales::percent) +
    scale_y_discrete(limits = rev) +  
    scale_fill_manual_interactive(
      labels = legend_labels,
      values = rev(pal_yes_no_6)
    ) +
    guides(fill = guide_legend(nrow = 1, byrow = TRUE)) +
    labs(
      fill = NULL,
      y = NULL,
      x = NULL,
      title = "Erfolg der Maßnahmen zur Teilnehmendengewinnung",
      subtitle = "in den Ortsgruppen"
    ) +
    theme(
      legend.position = "bottom",
      plot.title = element_text(
        hjust = 0.5,
        face = "bold",
        family = TS_FONT_FAMILY
      ),
      plot.subtitle = element_text(
        hjust = 0.5,
        family = TS_FONT_FAMILY
      ),
      legend.text = element_text(family = TS_FONT_FAMILY)
    )

  ggiraph::girafe(
    ggobj = p,
    options = list(
      ggiraph::opts_toolbar(saveaspng = TRUE)
    )
  )
}

```

Darüber hinaus wollten wir wissen, wie die Ortsgruppen auf die Gewinnung neuer Teilnehmer*innen blicken, d.h. welche Maßnahmen sie verfolgen und wie erfolgreich diese sind.

```{r massnahmen-tabset, echo=FALSE, results='asis'}
render_massnahmen_year <- function(ds) {
  mass_long <- calculate_massnahmen_long(ds)

  mass_choices <- ds$meta$og_choices %>%
    dplyr::filter(
      list_name == ds$cfg$og_cfg$Q_TN_GEWINNUNG_MASSNAHMEN$select_from_list_name
    ) %>%
    dplyr::mutate(
      label_short = stringr::str_to_title(
        stringr::str_replace_all(name, "_", " ")
      )
    ) %>%
    dplyr::transmute(
      massnahme = label,
      label_short
    )

  mass_count_agg <- mass_choices %>%
    dplyr::left_join(
      mass_long %>%
        dplyr::filter(massnahme != "Insgesamt") %>%
        dplyr::count(massnahme, label_short, name = "n"),
      by = c("massnahme", "label_short")
    ) %>%
    tidyr::replace_na(list(n = 0L))

  mass_erfolg_agg <- calculate_massnahmen_erfolg_agg(
    ds             = ds,
    mass_long      = mass_long,
    mass_count_agg = mass_count_agg
  )

  cat("::: {.panel-tabset}\n\n")
  cat("### Maßnahmen\n\n")
  render_widget_output(plot_massnahmen(mass_count_agg))
  cat("\n\n### Erfolg der Maßnahmen\n\n")
  render_widget_output(plot_massnahmen_erfolg(mass_erfolg_agg, ds))
  cat("\n\n:::\n")
}

mass_tab_curr <- list(year = current_year, ds = curr)
mass_tab_prev <- if (has_previous_year) list(year = previous_year, ds = prev) else NULL

render_year_tabset(
  curr_data = mass_tab_curr,
  prev_data = mass_tab_prev,
  render_fn = function(tab_data) render_massnahmen_year(tab_data$ds)
)
```

```{r datenquellen-massnahmen}
knitr::asis_output(callout_datenquellen(curr$cfg,
og_q=list("Q_TN_GEWINNUNG_MASSNAHMEN", "QS_TN_GEWINNUNG_MASSNAHMEN_ERFOLG_BEGIN")
))
```

# Unterstützungsbedarfe der Ortsgruppen

Um eure Ortsgruppe gezielt unterstützen zu können, bspw. bei der Gewinnung neuer Teilnehmender, und um Bedarfe besser erkennen zu können, wollten wir von euch wissen: Gibt es bei euch vor Ort gerade Probleme neue Teilnehmende zu finden? Was läuft gut? Und an welcher Stelle wünscht ihr euch, Unterstützung zu bekommen?

### Gibt es gerade Probleme neue Teilnehmende zu finden?

Hier seht ihr die Antworten der Ortsgruppen. Wenn Vorjahresdaten vorhanden sind, werden euch das aktuelle und letzte Jahr angezeigt. 

```{r tn-gewinnung-probleme}
#| fig.width: 9
#| fig.height: 6
#| echo: false
#| results: 'asis'
tn_has_subregions <- is_westbund

if (!tn_has_subregions) {
  choice_labels <- curr$meta$og_choices %>%
    filter(list_name == curr$cfg$og_cfg$Q_TN_GEWINNUNG_PROB$select_from_list_name) %>%
    pull(label) %>%
    unique()

  make_pct_table <- function(curr_vec, prev_vec, choices, include_prev) {
    data <- data.frame(
      choice = choices,
      curr   = sapply(choices, function(x) mean(curr_vec == x) * 100),
      row.names = NULL,
      check.names = FALSE
    )

    if (include_prev) {
      data$prev <- sapply(choices, function(x) mean(prev_vec == x) * 100)
    }

    data
  }

  tbl <- make_pct_table(
    curr_vec = curr$og$data$hat_probleme_tn_gewinnung,
    prev_vec = if (has_previous_year) prev$og$data$hat_probleme_tn_gewinnung else NULL,
    choices  = choice_labels,
    include_prev = has_previous_year
  )

  columns <- list(
    choice = colDef(
      name = "Gibt es Probleme neue Teilnehmende zu finden?"
    ),
    curr = colDef(
      name   = as.character(current_year),
      format = colFormat(digits = 0, suffix = "%")
    )
  )

  if (has_previous_year) {
    columns$prev <- colDef(
      name   = as.character(previous_year),
      format = colFormat(digits = 0, suffix = "%")
    )
  }

  column_groups <- if (has_previous_year) {
    list(
      colGroup(
        name    = "Anteil der Ortsgruppen in %",
        columns = c("curr", "prev")
      )
    )
  } else {
    NULL
  }

  reactable(
    tbl,
    columns = columns,
    columnGroups = column_groups,
    striped   = TRUE,
    highlight = TRUE,
    sortable  = FALSE
  )
} else {
  plot_tn_gewinnung <- function(og_data, og_lookup) {
    region_levels <- og_lookup |>
      dplyr::filter(!is.na(og_region)) |>
      dplyr::pull(og_region) |>
      as.character() |>
      unique() |>
      sort()

    plot_data <- og_data |>
      dplyr::filter(!is.na(hat_probleme_tn_gewinnung)) |>
      dplyr::left_join(
        og_lookup |> dplyr::select(og_name, og_region),
        by     = "og_name",
        suffix = c("", "_lookup")
      ) |>
      dplyr::filter(!is.na(og_region)) |>
      dplyr::group_by(og_region, hat_probleme_tn_gewinnung) |>
      dplyr::summarise(n = dplyr::n(), .groups = "drop_last") |>
      dplyr::mutate(perc = n / sum(n)) |>
      dplyr::ungroup() |>
      dplyr::mutate(
        og_region = factor(og_region, levels = region_levels),
        hat_probleme_tn_gewinnung = factor(
          hat_probleme_tn_gewinnung,
          levels = c(
            "Nein",
            "Ja, aber nur phasenweise",
            "Ja, sehr große Probleme"
          )
        )
      )

    if (nrow(plot_data) == 0) {
      return(ts_no_data_girafe())
    }

    p <- ggplot(
      plot_data,
      aes(x = og_region, y = perc, fill = hat_probleme_tn_gewinnung)
    ) +
      ggiraph::geom_col_interactive(
        aes(
          tooltip = paste0(
            og_region, "\n",
            hat_probleme_tn_gewinnung, ": ",
            fmt_perc(perc)
          ),
          data_id = paste(og_region, hat_probleme_tn_gewinnung, sep = "-")
        )
      ) +
      scale_x_discrete(drop = FALSE) +
      scale_y_continuous(labels = fmt_perc) +
      scale_fill_manual(values = c(pal_yes_no_3)) +
      labs(
        title = "Probleme bei Teilnehmendengewinnung",
        x = NULL,
        y = "% der Ortsgruppen",
        fill = NULL
      ) +
      theme_minimal(base_size = 12, base_family = TS_FONT_FAMILY) +
      theme(
        plot.title = element_text(
          size = 20,
          face = "bold",
          hjust = 0.5,
          family = TS_FONT_FAMILY
        ),
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major.x = element_blank()
      )

    ggiraph::girafe(
      ggobj = p,
      options = list(
        ggiraph::opts_toolbar(saveaspng = TRUE)
      )
    )
  }

  tn_gewinnung_curr <- curr$og$data
  tn_gewinnung_prev <- if (has_previous_year) prev$og$data else NULL

  tn_gewinnung_curr_lookup <- curr$og$agg$total_tn_by_og |>
    dplyr::distinct(og_name, og_region)

  tn_gewinnung_prev_lookup <- if (has_previous_year) {
    prev$og$agg$total_tn_by_og |>
      dplyr::distinct(og_name, og_region)
  } else {
    NULL
  }

  tn_gewinnung_tabs <- list(
    curr = list(
      year   = current_year,
      data   = tn_gewinnung_curr,
      lookup = tn_gewinnung_curr_lookup
    )
  )

  tn_gewinnung_tabs$prev <- if (has_previous_year) {
    list(
      year   = previous_year,
      data   = tn_gewinnung_prev,
      lookup = tn_gewinnung_prev_lookup
    )
  } else {
    NULL
  }

  render_tn_gewinnung_plot <- function(tab_data) {
    widget <- plot_tn_gewinnung(tab_data$data, tab_data$lookup)
    render_widget_output(widget)
  }

  render_year_tabset(
    curr_data = tn_gewinnung_tabs$curr,
    prev_data = tn_gewinnung_tabs$prev,
    render_fn = render_tn_gewinnung_plot
  )
}


knitr::asis_output(callout_datenquellen(curr$cfg,
og_q=list("Q_TN_GEWINNUNG_PROB")
))

```

### An welcher Stelle gibt es Unterstützungsbedarfe?

```{r calc-unterst-table}
calculate_unterst_order <- function(ds) {
  order_df <- ds$meta$og_choices %>% 
  filter(list_name %in% ds$cfg$og_cfg$QS_UNTERSTUETZUNGSBEDARFE$select_from_list_name) %>% 
  mutate(order = c(0:1, 2:3, NA)) %>%
  select(order, bedarf_value = label) %>% 
  arrange(order)
  order_df
}

calculate_unterst_table <- function(ds) {
  og_ueb<- ds$og$long$unterstuetzungsbedarfe |> 
    left_join(calculate_unterst_order(ds), by = "bedarf_value") |> 
    left_join(ds$og$data |> select(og_id, og_name), by = "og_id")

  og_ueb_sum <- og_ueb |> 
    group_by(bedarf) |> 
    summarize(median_bedarf = median(order, na.rm = TRUE),
              bedarf_mean = mean(order, na.rm = TRUE),
            sd = sd(order, na.rm = TRUE),
            range = max(order, na.rm = TRUE) - min(order, na.rm = TRUE),
            sd_label = cut(range, breaks = c(0, 1, 3), labels = c("konstant", "variierend"), right = TRUE, include.lowest = TRUE),
            bedarf_label = cut(bedarf_mean, breaks = c(0, 1, 2, 3), labels = c("gering", "mittel", "hoch"), right = TRUE))
    og_ueb_sum
}

display_unterst_table<-function(og_ueb_sum){
  reactable::reactable(og_ueb_sum|> select(bedarf, bedarf_mean, bedarf_label,erklärung), 
    columns = list(
      bedarf = colDef(name = ""),
      bedarf_mean = colDef(show = FALSE), 
      bedarf_label = colDef(name = "⌀ Bedarf", cell = function(value) {
      switch(
        as.character(value),
          gering = htmltools::span(value, class = "badge bg-success"),
          mittel = htmltools::span(value, class = "badge bg-warning"),
          hoch = htmltools::span(value, class = "badge bg-danger"))   
      }),
      erklärung = colDef(name = "Erklärung")
    ))
}

add_explanation_to_bedarf <- function(og_ueb_sum){
  og_ueb_sum <- og_ueb_sum %>%
  mutate(
    erklärung_bedarf = case_when(
      bedarf_label == "hoch"   ~ "Der Bedarf ist hoch",
      bedarf_label == "mittel" ~ "Der Bedarf ist mittel ",
      bedarf_label == "gering" ~ "Der Bedarf ist gering ",
      TRUE ~NA_character_
    ),
    erklärung_streuung = case_when(
      sd_label == "konstant"   ~ "und über die Ortsgruppen hinweg relativ einheitlich.",
      sd_label == "variierend" ~ "aber variiert zwischen den Ortsgruppen.",
      TRUE ~NA_character_
    ),
    erklärung = ifelse(
      is.na(erklärung_bedarf) | is.na(erklärung_streuung),
      "Nicht genug Informationen *",
      paste(erklärung_bedarf, erklärung_streuung)
    )
  )%>%
  select(-erklärung_bedarf, -erklärung_streuung) 
og_ueb_sum
}
```


```{r unterstuetzung-tabset, echo=FALSE, results='asis'}
#| fig.width: 9
#| fig.height: 6
unterstuetzung_tabs <- list(
  curr = list(
    year = current_year,
    data = add_explanation_to_bedarf(calculate_unterst_table(curr))
  )
)

unterstuetzung_tabs$prev <- if (has_previous_year) {
  list(
    year = previous_year,
    data = add_explanation_to_bedarf(calculate_unterst_table(prev))
  )
} else {
  NULL
}

render_unterstuetzung_table <- function(tab_data) {
  render_widget_output(display_unterst_table(tab_data$data))
}

render_year_tabset(
  curr_data = unterstuetzung_tabs$curr,
  prev_data = unterstuetzung_tabs$prev,
  render_fn = render_unterstuetzung_table
)

knitr::asis_output(callout_datenquellen(curr$cfg,
og_q=list("Q_BEGIN_UNTERSTUETZUNGSBEDARFE"),extra="⚠️ * *Nicht genug Informationen* heißt entweder, dass diese Frage von den Ortsgruppen gar nicht oder mit 'Bin mir unsicher' ausgefüllt wurde."
))

```
